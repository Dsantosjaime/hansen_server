import{CompoundCondition as t,FieldCondition as e,ObjectQueryParser as r,NULL_CONDITION as n,buildAnd as o,createTranslatorFactory as s}from"@ucast/core";import{createJsInterpreter as a,or as i,and as c,gte as l,gt as u,lte as p,lt as f,within as y,ne as d,eq as w,compare as h}from"@ucast/js";import{rulesToQuery as b}from"@casl/ability/extra";import{ForbiddenError as m,PureAbility as g,fieldPatternMatcher as v}from"@casl/ability";class A extends Error{static invalidArgument(t,e,r){const n=`${typeof e}(${JSON.stringify(e,null,2)})`;return new this(`"${t}" expects to receive ${r} but instead got "${n}"`)}}const O=t=>t&&(t.constructor===Object||!t.constructor);const j={type:"field",validate(t,e){if(Array.isArray(e)||O(e))throw new A(`"${t.name}" does not supports comparison of arrays and objects`)}};const N={type:"field",parse(r,n,{hasOperators:o,field:s,parse:a}){if(O(n)&&!o(n)||Array.isArray(n))throw new A(`"${r.name}" does not supports comparison of arrays and objects`);if(!O(n))return new e("notEquals",s,n);return new t("NOT",[a(n,{field:s})])}};const $={type:"field",validate(t,e){if(!Array.isArray(e))throw A.invalidArgument(t.name,e,"an array")}};const x={type:"field",validate(t,e){const r=typeof e;const n=r==="string"||r==="number"&&Number.isFinite(e)||e instanceof Date;if(!n)throw A.invalidArgument(t.name,e,"comparable value")}};const E=new Set(["insensitive","default"]);const q={type:"field",validate(t,e){if(!E.has(e))throw A.invalidArgument(t.name,e,`one of ${Array.from(E).join(", ")}`)},parse:()=>n};const S={type:"field",validate(t,e){if(typeof e!=="string")throw A.invalidArgument(t.name,e,"string")},parse(t,r,{query:n,field:o}){const s=n.mode==="insensitive"?`i${t.name}`:t.name;return new e(s,o,r)}};const T={type:"compound",validate(t,e){if(!e||typeof e!=="object")throw A.invalidArgument(t.name,e,"an array or object")},parse(e,r,{parse:n}){const o=Array.isArray(r)?r:[r];const s=o.map(t=>n(t));return new t(e.name,s)}};const W={type:"field",validate(t,e){if(typeof e!=="boolean")throw A.invalidArgument(t.name,e,"a boolean")}};const _={type:"field"};const D={type:"field",validate(t,e){if(!Array.isArray(e))throw A.invalidArgument(t.name,e,"an array")}};const C={type:"field",parse(t,r,{field:n,parse:o}){if(!O(r))throw A.invalidArgument(t.name,r,"a query for nested relation");return new e(t.name,n,o(r))}};const F=(r,n)=>{const o=n.parse;if(!o)return Object.assign({},n,{parse(n,o,s){return new t("NOT",[new e(r,s.field,o)])}});return Object.assign({},n,{parse(e,n,s){const a=o(e,n,s);if(a.operator!==e.name)throw new Error(`Cannot invert "${r}" operator parser because it returns a complex Condition`);a.operator=r;return new t("NOT",[a])}})};const I={equals:j,not:N,in:$,notIn:F("in",$),lt:x,lte:x,gt:x,gte:x,mode:q,startsWith:S,endsWith:S,contains:S,isEmpty:W,has:_,hasSome:D,hasEvery:D,NOT:T,AND:T,OR:T,every:C,some:C,none:F("some",C),is:C,isNot:F("is",C),isSet:W};class M extends r{constructor(){super(I,{defaultOperatorName:"equals"})}parse(t,e){if(e&&e.field)return o(this.parseFieldOperators(e.field,t));return super.parse(t)}}const P=(t,e,{get:r})=>r(e,t.field).startsWith(t.value);const R=(t,e,{get:r})=>r(e,t.field).toLowerCase().startsWith(t.value.toLowerCase());const J=(t,e,{get:r})=>r(e,t.field).endsWith(t.value);const k=(t,e,{get:r})=>r(e,t.field).toLowerCase().endsWith(t.value.toLowerCase());const z=(t,e,{get:r})=>r(e,t.field).includes(t.value);const B=(t,e,{get:r})=>r(e,t.field).toLowerCase().includes(t.value.toLowerCase());const G=(t,e,{get:r})=>{const n=r(e,t.field);const o=Array.isArray(n)&&n.length===0;return o===t.value};const H=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&n.includes(t.value)};const K=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&t.value.some(t=>n.includes(t))};const L=(t,e,{get:r})=>{const n=r(e,t.field);return Array.isArray(n)&&t.value.every(t=>n.includes(t))};const Q=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return Array.isArray(o)&&o.length>0&&o.every(e=>n(t.value,e))};const U=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return Array.isArray(o)&&o.some(e=>n(t.value,e))};const V=(t,e,{get:r,interpret:n})=>{const o=r(e,t.field);return o&&typeof o==="object"&&n(t.value,o)};const X=(t,e,{interpret:r})=>t.value.every(t=>!r(t,e));const Y=(t,e,{get:r})=>{const n=r(e,t.field);return n!==void 0};function Z(t){return t&&typeof t==="object"?t.valueOf():t}const tt=(t,e)=>h(Z(t),Z(e));const et=a({equals:w,notEquals:d,in:y,lt:f,lte:p,gt:u,gte:l,startsWith:P,istartsWith:R,endsWith:J,iendsWith:k,contains:z,icontains:B,isEmpty:G,has:H,hasSome:K,hasEvery:L,and:c,or:i,AND:c,OR:i,NOT:X,every:Q,some:U,is:V,isSet:Y},{get:(t,e)=>t[e],compare:tt});const rt=new M;const nt=s(rt.parse,et);function ot(t){return t.inverted?{NOT:t.conditions}:t.conditions}const st={get(t,e){const r=b(t.t,t.o,e,ot);if(r===null){const r=m.from(t.t).setMessage(`It's not allowed to run "${t.o}" on "${e}"`);r.action=t.o;r.subjectType=r.subject=e;throw r}const n=Object.create(null);if(r.$or)n.OR=r.$or;if(r.$and)n.AND=r.$and;return n}};const at=()=>function t(e,r="read"){return new Proxy({t:e,o:r},st)};function it(t,e="read"){return new Proxy({t:t,o:e},st)}function createAbilityFactory(){function createAbility(t=[],e={}){return new g(t,Object.assign({},e,{conditionsMatcher:nt,fieldMatcher:v}))}return createAbility}export{A as ParsingQueryError,it as accessibleBy,createAbilityFactory,at as createAccessibleByFactory,nt as prismaQuery};
//# sourceMappingURL=runtime.mjs.map
